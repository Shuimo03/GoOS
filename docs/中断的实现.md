## 概念介绍

### 先实现中断的原因

在完整整个操作系统的过程中，会出现各种不可预知的异常错误，假设在系统宕机了，会让开发者不知所措。

而先实现中断包括异常处理的能力，那么由于某种编程失效所导致异常时，OS就能感受到异常，并且提供相关的信息(比如异常出现的原因，异常产生的地址等等)提供给开发者，有利于开发者修改程序。

除此之外，中断机制，尤其是时钟中断，是实现后续进程切换与调度，系统服务机制等等的基础。

### 中断

中断是操作系统上首先需要实现的功能，因为它是操作系统所有功能的基础，假设没有中断，操作系统在唤起一个用户程序之后，就需要等到用户程序执行完之后才能继续执行，那操作系统就没有办法进行资源调度。

### 中断的分类

+ 异常
+ 陷入
+ 外部中断

### 异常(exception)

异常是指在执行一条指令的过程中发生了错误，这个时候就需要通过中断来处理错误，最常见的异常包括：

+ 访问无效内存地址
+ 执行非法指令(除零)
+ 发生缺页等等

这些异常有的可以恢复，比如缺页，有的不能恢复，比如除零。只能终止程序执行。

### 陷入(trap)

主动通过一条指令停下来，并跳转到处理函数，常见的形式有通过ecall进行系统调用或者通过ebreak进入断点。

### 外部中断(interrupt / Hardware Interrupt)

指的是CPU的执行过程中被外部设备发来的信号打断，这个时候就必须停下来对外部设备进行处理，比较典型的有定时器倒计时结束，串口收到数据等等。

外部中断是一个异步的过程，CPU并不清楚外部中断会什么时候发生，CPU也不需要一直在原地等待外部中断的发生。

而是执行代码，有了外部中断才去处理，因为CPU 的主频远高于 I/O 设备，这样避免了 CPU 资源的浪费。

## RISC-V中断

### RISC-V的权限状态

+ **Machine Mode 机器态**
  + Machine Mode是RISC-V中最高权限模式，一些底层的操作指令只能让机器态使用。
  + 所有标准的RISC-V处理器都必须实现的模式。
  + 默认所有中断实际上都是交给机器态处理，但是为了实现更多的功能，机器态会将某些中断交给内核态处理，这些异常也是我们编写操作系统所需要实现的。
+ **Supervisor Mode 内核态**
  + 通常是操作系统使用，可以访问一些supervisor级别的寄存器，通过这些寄存器对中断和虚拟内存映射进行管理。
  + Unix系统中，大部分中断都是内核态的系统调用，机器态可能通过异常委托机制将一部分中断设置为不经过机器态，直接由内核态处理。
+ **User Mode**

### 与中断相关的寄存器

在内核态和机器态中，RISC-V设计了一些CSR(Control and Status Registers)寄存器用来保存控制信息。

#### 发生中断时，硬件自动填写的寄存器

+ sepc：用来记录触发中断的指令地址。
+ scause：记录中断是否为硬件中断，以及具体中断的原因。
+ stval：因为scause空间有限，不能存下所有的中断信息，比如缺页异常，就会把stval设置成需要访问但是不在内存中的地址，以便于操作系统必须将这个地址所在的页面加载进来。

#### 指导硬件处理中断的寄存器

+ stvec
+ sstatus：具有许多状态位，控制全局中断使能等。
+ sie
+ sip
+ sscratch

#### 与中断相关的指令

+ ecall
+ sret
+ ebreak
+ mret

### CSR寄存器

## 程序的运行状态

对于用户程序来说，中断处理应该是不留任何痕迹的，只要中断处理改动一个寄存器都可能导致原本正在运行的线程出现错误。

所以在处理终端之前，必须要保存所有可能被修改的寄存器，并且在修改之后能够恢复。这样的话，就需要保存所有的通用寄存器。

### Context

## 状态的保存与恢复



## X86对比RISC-V的中断

## 实现过程

debug一次中断查看中断的过程。