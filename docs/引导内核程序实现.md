### 引导启动

当我们按下开机键的时候，主板ROM内存储的固件将会启动，它将负责电脑的加电自检，可用内存的检测，以及CPU和其他硬件的加载。

之后，它将寻找一个可引用的存储介质，并且开始引导启动其中的内核。


### 调整内存布局

```
kernel:	file format elf64-littleriscv
architecture: riscv64
start address: 0x0000000000011120

Program Header:
    PHDR off    0x0000000000000040 vaddr 0x0000000000010040 paddr 0x0000000000010040 align 2**3
         filesz 0x00000000000000e0 memsz 0x00000000000000e0 flags r--
    LOAD off    0x0000000000000000 vaddr 0x0000000000010000 paddr 0x0000000000010000 align 2**12
         filesz 0x0000000000000120 memsz 0x0000000000000120 flags r--
    LOAD off    0x0000000000000120 vaddr 0x0000000000011120 paddr 0x0000000000011120 align 2**12
         filesz 0x0000000000000004 memsz 0x0000000000000004 flags r-x
   STACK off    0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**64
         filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-
```

start address是程序的入口地址，默认被放在0x0000000000011120，这对于普通用户来说，代码和数据一般都在低地址空间上。

但是对于操作系统内核来说，一般是把地址放在高地址上，并且在 QEMU 模拟的 RISC-V 中，DRAM 内存的物理地址是从 0x80000000 开始，有 128MB 大小，所以需要调整程序的内存布局。

### 程序的内存布局

一般来说，一个程序按照不同的功能分为以下不同的段：

+ text 段：代码段，存放汇编代码
+ rodata 段：只读数据段，顾名思义里面存放只读数据，通常是程序中的常量
+ data 段：存放被初始化的可读写数据，通常保存程序中的全局变量
+ bss 段：存放被初始化为 0 的可读写数据，与 .data 段的不同之处在于我们知道它要被初始化为 0，因此在可执行文件中只需记录这个段的大小以及所在位置即可，而不用记录里面的数据，也不会实际占用二进制文件的空间
+ Stack：栈，用来存储程序运行过程中的局部变量，以及负责函数调用时的各种机制。它从高地址向低地址增长
+ Heap：堆，用来支持程序运行过程中内存的动态分配，比如说你要读进来一个字符串，在你写程序的时候你也不知道它的长度究竟为多少，于是你只能在运行过程中，知道了字符串的长度之后，再在堆中给这个字符串分配内存。

### 编写链接脚本

使用链接脚本来指定程序的内存布局，BASE_ADDRESS地址选择0x80200000，因为OpenSBI将自身放在0x80000000，完成初始化之后就会跳转到0x80200000，所以_start 必须位于这个地址。.text 为代码段标识，其第一个放置的就是 _start（即 .text.entry）。

### 重写程序入口点 _start

在CPU加电或者reset后，它首先会自检，通过自检之后会跳到启动代码(bootloader)入口，在bootloader中，先进行外设探测，并对内核的运行环境进行初步设置。随后，bootloader 会将内核代码从硬盘加载到内存中，并跳转到内核入口，正式进入内核。也就是说，CPU 所执行的第一条指令其实是指 bootloader 的第一条指令。

这里并不自己实现一个bootloader，直接使用现成的OpenSBI固件，固件是一种特定的计算机软件，它为设备的特定硬件提供低级控制进一步加载其他软件的功能。固件可以为设备更复杂的软件（如操作系统）提供标准化的操作环境，或者，对于不太复杂的设备，充当设备的完整操作系统，执行所有控制、监视和数据操作功能。

在X86的计算机系统中有两种固件标准:BIOS和UEFI，其中BIOS 标准显得陈旧而过时，但实现简单，并为 1980 年代后的所有 x86 设备所支持；相反地，UEFI 更现代化，功能也更全面，但开发和构建更复杂。

在基于RISC-V的计算机系统中，可以使用OpenSBI，OpenSBI 固件运行在特权级别很高的计算机硬件环境中，即 RISC-V 64 的 M Mode。

### RISC-V的特权级

RISC-V一共有三种特权级:
+ u Mode(User/Application模式)
+ S Mode(Supervisor 模式)
+ M Mode(Machine 模式)

### 知识点补充

+ 高地址
+ 低地址
+ 内存布局
+ 内存分配