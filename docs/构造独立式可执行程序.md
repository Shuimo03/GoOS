## 安装所需要的工具

Rust工具链:

+ Rust版本工具: rustup
+ Rust软件包管理工具: cargo
+ Rust编译器: rstc
+ 其他(待定)

虚拟机软件:qemu.


## 创建Rust项目

因为我们创建的是一个可执行文件而不是一个库，所以在创建的时候命令如下:

```
cargo new projectname
```

随后在目录下创建一个rust-toolchain的文件，在其中写入所需要的工具链版本

## 独立式可执行程序

创建一个不带有标准库的可执行文件，就是一个独立式可执行程序。因为我使用的是rust，所以会创建一个不链接标准库的Rust可执行文件。要编写一个操作系统内核，就需要编写不需要依赖操作系统特性的代码，这意味着不能使用线程、文件、堆内存、网络、随机数、标准输出，或其它任何需要操作系统抽象和特定硬件的特性。所以操作系统和硬件驱动都是需要我们自己来写。

## 禁用标准库

在默认情况下，所有的rust包都会链接到标准库，而标准库都会依赖于操作系统功能，比如线程、文件系统、网络。标准库还有Rust和C语言标准库实现的库相关联。

所以我们必须禁用标准库自动引用，可以使用no_std来实现这一点，在目录下创建.cargo目录，然后创建config文件并在里面输入以下内容:

```
# os/.cargo/config
[build]
target = "riscv64gc-unknown-none-elf"
```

现在默认会使用RISC64gc作为目标平台，而不是原来的x86_64-unknown-linux-gnu，实际上，这是一种编译器运行的平台和可执行文件运行的目标平台(riscv-64)不同的情况。这种情况称为**交叉编译**。

在cargo出来的项目中，找到main.rs，然后加上一行#![no_std]来告诉Rust编译器不使用Rust标准库而使用核心库，核心库并不需要操作系统的支持。

### 实现自己的panic!宏

panic的作用是在遇到一些无法恢复的致命错误，导致程序没有办法向下运行的时候，需要通过panic来打印出错的位置，并且能够意识到它的存在，并进行后续的一些处理。

panic!宏最经典的应用场景包括断言宏assert!失败或者对`Option::None/Result::Err` 进行 `unwrap` 操作。在标准库中提供panic的处理函数时#[panic_handler]，大致功能时打印出错位置和原因随后杀死当前应用。因为我们并不适用标准库，而核心库(core)并没有提供panic。所以就需要自己实现一个。

## 内核的第一条指令

再动手实现内核之前，先复习一遍计算机组成原理的基本知识，计算机主要是由三个部分组成:

+ CPU
+ 物理内存
+ IO外设

前期的主要重心是放在CPU和物理内存上，CPU的主要功能是从物理内存中读取指令，译码并执行，在这个过程中物理内存还需要和IO外设打交道。物理内存作为计算机体系结构中一个重要的部分，CPU 唯一能够直接访问的只有物理内存中的数据，它可以通过访存指令来达到这一目的。

在CPU的角度来看物理内存，它是一个大字节数组，而物理地址则是对应一个能够用来访问数组中某个元素的下标，但是和普通的数组不一样的地方在于它的下标不是以0开头，而是一个常数，比如0x80000000开头。

当CPU以多字节(比如2/4/8或者更多)为单位访问物理内存(事实上并不局限于物理内存，也包括I/O外设的数据空间)中的数据时，就有可能引入端序(字节顺序)和内存对齐的问题。

### 端序

端序或尾序（Endianness），又称字节顺序。指的是电脑内存中或者在数字通信链路中，多字节组成的字（Word）的字节（Byte）的排列顺序。字节的排列方式有两个通用规则。

+ 小端序：将一个多位数的低位放在较小的地址处，高位放在较大的地址处。
+ 大端序：将一个多位数的低位放在较大的地址处，低位放在较小的地址处。

### 内存地址对齐

**TODO 值得单独写一篇博客**

内存地址对齐是内存中的数据排列，以及 CPU 访问内存数据的方式，包含了基本数据对齐和结构体数据对齐的两部分。CPU在内存中的读写数据按照**字节块**进行操作，在理论上任意类型的变量都可以访问从内存的任何地址开始。

但是在计算机系统中，CPU是通过数据总线和地址总线来访问内存，数据总线决定了每次读取的数据位数，地址总线决定了寻址范围。基于计算机的物理组成和性能需求，CPU一般会要求访问内存数据的首地址的值为4或者8的整数倍。

基本类型数据对齐是指数据在内存中的偏移地址必须是一个字的整数倍，这种存储数据的方式能够提升系统在读取数据时的性能。结构体数据对齐是指在结构体中的上一个数据域结束和下一个数据域开始的地方填充一些没有用的字节，来保证每个数据域(假设是基本类型数据)都能够按照基本类型对齐。

## 关于qemu模拟器

qemu是一个开源的模拟器和虚拟机，qemu的主要应用场景在于它可以作为一个系统仿真机(system emulation)，它提供了一套计算机的虚拟化：

+ CPU
+ 内存
+ 设备(emulated devices)

从makefile中来看如何使用qemu:

```makefile
@qemu-system-riscv64 \
            -machine virt \
            -nographic \
            -bios default \
            -device loader,file=$(BIN_FILE),addr=0x80200000
```

+ -machine virt表示将模拟的64位RISC-V计算机设置为virt的通用虚拟平台，因为就算是同一种指令集结构(ISA),也会由很多种不同的计算机配置，比如CPU的生产商，就算是同一个生产商，都会有不同的型号，支持的IO外设种类也不同。
+ -nographic表示不使用GUI，只需要输出字符流。
+ -bios可以设置 Qemu 模拟器开机时用来初始化的引导加载程序(bootloader)。
+ -device loader可以在 Qemu 模拟器开机之前将一个宿主机上的文件载入到 Qemu 的物理内存的指定位置中，file和addr分别可以设置待载入文件的路径和将文件宅如到Qemu物理内存上的物理地址。

### Qemu启动流程

virt平台上，物理内存的起始地址是0x80000000，物理内存默认大小是128MIB，可以通过-m选项进行配置，rCore的教程中提到说，只会用到最低的8MIB物理内存。对应的物理地址区间是[0x80000000,0x80800000)。

使用上面的命令启动qemu，会在qemu开始执行任何指令之前，首先将两个文件加载到qemu的物理内存中，但是我的bios是使用qemu默认的，不过同样会被加载到0x80000000上。

然后file也就是内核镜像会被加载到物理地址0x80200000开头的区域上。

至于为什么会被加载到这两个位置上，这就和qemu模拟计算机加电启动后的运行流程有关系，一般来说计算机在加电之后的启动流程可以分为多个阶段，每个阶段都由一层软件负责，每一层软件的功能都进行它的初始化工作，完成之后在跳转到下一层软件的入口地址。

qemu的模拟启动流程分为三个阶段：

+ 第一阶段写死在Qemu内的一小段汇编程序负责。
+ 第二阶段由bootloader负责。
+ 第三阶段由内核镜像负责。

**TODO 添加更多细节**

## 程序内存布局与编译流程

### 程序内存布局

当代码被编译成可执行文件之后，它就会变成一个杂乱无序的字节文件，但是字节文件至少可以分为两个部分，那就是数据和代码。在程序运行起来的时候它们的功能是并不相同的：代码部分是由一条条可以被CPU解码并执行的指令组成。数据部分是被CPU当作可读写的内存空间。

不过还可以根据功能再进一步的把两个部分划分为更小的单位：段。不同的段会被编译器放在内存中不同的位置上，这样就构成了内存布局。一种典型的内存布局如下：

+ 高地址
+ 数据内存
+ 代码内存
+ 低地址

**TODO 画图**



## 交叉编译与本地编译

本地编译是指在当前平台(由CPU和操作系统组成的)下编译出来的程序，那这个程序只能在当前平台下运行，比如基于x86-64平台上的程序只能在x86-64平台上执行。

而交叉编译是指在一种平台上编译出另外一种平台上运行的程序，程序编译的环境和运行的环境不一致，比如说在x86-64平台上编写的代码，编译出RISC-V的程序。

## 参考

+ https://os.phil-opp.com/zh-CN/freestanding-rust-binary/
+ https://rcore-os.github.io/rCore-Tutorial-Book-v3/chapter0/index.html
+ [移除标准库依赖 — rCore-Tutorial-Book-v3 3.6.0-alpha.1 文档 (rcore-os.github.io)](https://rcore-os.github.io/rCore-Tutorial-Book-v3/chapter1/2remove-std.html)
+ [‘virt’ Generic Virtual Platform (virt) — QEMU documentation](https://www.qemu.org/docs/master/system/riscv/virt.html)